#!/usr/bin/env ruby -wU --disable-all

require "digest/sha2"
require "fileutils"
require "find"
require "io/console"
require "json"
require "net/http"
require "open3"
require "optparse"
require "pathname"
require "psych"
require "rbconfig"
require "rubygems" # TODO write a simple version of Gem::Package::TarReader?
require "rubygems/package"
require "set"
require "shellwords"
require "stringio"
require "strscan"
require "tempfile"
require "tmpdir"
require "uri"
require "zlib"

# We run the build with parallel workers, in threads.
# When any given thread raises, we want to stop the build immediately.
# We kill report_on_exception so we don't see the trace twice.
Thread.abort_on_exception = true
Thread.report_on_exception = false

module Wake
  def self.run(*args)
    options = { jobs: 1 }
    parser = OptionParser.new
    parser.on("-j", "--jobs=NUM", Integer)
    parser.order(args, into: options)

    console = Console.new(STDOUT)
    $stdout = console

    registry = Registry.new

    define_rules(registry, console: console)

    Pathname.glob("**/BUILD") do |build|
      registry.new_package(build.dirname.to_path).instance_eval(build.read, build.to_path)
    end

    targets = registry.resolve(platform: Platform.new(host_os: RbConfig::CONFIG.fetch("host_os")))
    filesystem = RealFilesystem.new(Dir.pwd)
    providers = ProviderRegistry.new

    plan = Plan.new(targets.keys) { |label| targets.fetch(label).dependencies }

    workers = Array.new(options.fetch(:jobs)) do
      Thread.new do
        plan.each do |label|
          context = Context.new(filesystem, providers, label)
          target = targets.fetch(label)
          console.report_target_invocation(label)
          target.invoke(context)
          console.report_target_completion(label)
        end
      end
    end

    workers.each(&:join)

    broken_tests = []
    tests = providers.of(TestExecutableInfo)
    test_plan = Plan.new(tests.keys) { |label| [] } # no dependencies
    test_plan.each do |label|
      test = tests.fetch(label)
      test.run do |test_case|
        console.report_test_result(test_case)
        broken_tests << test_case if test_case.broken?
      end
    end

    console.join

    # TODO var/cache is duplication with Actions
    filesystem.purge("var/cache", before: Time.now - (60 * 60 * 24))

    broken_tests.count
  end

  def self.define_rules(registry, console:)
    registry.new_target(
      label: Label.parse("//tools:console"),
      # Dummy for now because ruby 2.5.3 on Travis otherwise complains splatting no kwargs.
      rule: lambda { |context, dummy:| [console] },
      common: Target::COMMON.parse({ name: "console" }),
      attributes: AttributeSchema.new({ dummy: Attribute.new(String) }).parse({ dummy: "42" }),
    )

    registry.new_target(
      label: Label.parse("//tools:http"),
      rule: lambda { |context, console:| [HttpDownloader.new(console.fetch(Console))] },
      common: Target::COMMON.parse({ name: "http" }),
      attributes: AttributeSchema.new({
        console: Attribute.new(Label, default: "//tools:console", providers: [Console]),
      }).parse({}),
    )

    registry.new_rule(
      :http_file,
      attributes: {
        http: Attribute.new(Label, default: "//tools:http", providers: [HttpDownloader]),
        url: Attribute.new(URI),
        sha256: Attribute.new(Verifier),
      },
      implementation: ->(context, http:, url:, sha256:) {
        path = context.expand_path(url.path.split("/").last)
        # TODO work back in (a new kind of?) verifier
        context.run(parameters: [url], outputs: [path]) do |fs|
          fs.open(path, "wb") do |io|
            http.fetch(HttpDownloader).get(url, io)
          end
        end
        [FileInfo.new(path)]
      },
    )

    registry.new_rule(
      :file,
      attributes: {
        path: Attribute.new(String),
        content: Attribute.new(String),
      },
      implementation: ->(context, path:, content:) {
        full_path = context.expand_path(path)

        context.run(inputs: [], parameters: [content], outputs: [full_path]) do |fs|
          fs.open(full_path, "wb") { |io| io.write(content) }
        end

        [
          FileInfo.new(path: full_path),
          FileGroupInfo.new([full_path]),
        ]
      },
    )

    registry.new_rule(
      :extract,
      attributes: {
        archive: Attribute.new(Label, providers: [FileInfo]),
        format: Attribute.new(Symbol),
        paths: Attribute.new(String, list: true),
        strip_components: Attribute.new(PathCleaner, default: 0),
        suffix: Attribute.new(String, default: ""),
      },
      implementation: ->(context, archive:, format:, paths:, strip_components:, suffix:) {
        extractor = case format
          when :tar_gz
            TarGzip
          else
            raise "Unsupported Extractor #{format}"
          end

        context.run(
          inputs: [archive.fetch(FileInfo).path],
          parameters: [format, paths, strip_components],
          outputs: paths.map { |path| context.expand_path(path).concat(suffix) },
        ) do |fs|
          fs.open(archive.fetch(FileInfo).path, "rb") do |archive_io|
            extractor.foreach(archive_io) do |entry_path, entry_io, entry_mode|
              if entry_path = strip_components.stripped_path(entry_path)
                if paths.include?(entry_path)
                  fs.open(context.expand_path(entry_path).concat(suffix), "wb", permissions: entry_mode & 01555) do |output_io|
                    IO.copy_stream(entry_io, output_io)
                  end
                end
              end
            end
          end
        end

        file_group_info = FileGroupInfo.new(paths.map { |path| context.expand_path(path).concat(suffix) })
        result = [file_group_info]
        result << FileInfo.new(file_group_info.only) if paths.length == 1
        result
      },
    )

    registry.new_rule(
      :java_archiver,
      attributes: {
        jar: Attribute.new(Label, providers: [FileInfo]),
        libs: Attribute.new(Label, providers: [FileGroupInfo]),
      },
      implementation: ->(context, jar:, libs:) {
        [JavaArchiverInfo.new(
          jar: jar.fetch(FileInfo).path,
          libs: libs.fetch(FileGroupInfo).paths,
        )]
      },
    )

    registry.new_rule(
      :java_import,
      attributes: {
        jar: Attribute.new(Label, providers: [FileInfo]),
      },
      implementation: ->(context, jar:) {
        [JavaInfo.new(
          jar: jar.fetch(FileInfo).path,
          deps: [],
        )]
      },
    )

    registry.new_rule(
      :java_lib_with_resources,
      attributes: {
        archiver: Attribute.new(Label, default: "//lib/java:archiver", providers: [JavaArchiverInfo]),
        jar: Attribute.new(Label, providers: [JavaInfo]),
        services: Attribute.new(Hash, default: {}),
      },
      implementation: ->(context, archiver:, jar:, services:) {
        archiver = archiver.fetch(JavaArchiverInfo)
        java_info = jar.fetch(JavaInfo)
        raw = java_info.jar

        output = context.expand_path("lib%{name}.jar")

        context.run(
          inputs: [*archiver.files, raw],
          parameters: [*services],
          outputs: [output],
        ) do |fs|
          # TODO more efficient copy?
          fs.open(raw, "rb") { |raw| fs.open(output, "wb") { |cooked| IO.copy_stream(raw, cooked) } }

          services.each do |interface, provider|
            fs.open("META-INF/services/#{interface}", "wb") { |io| io.puts(provider) }
          end

          fs.exec!(archiver.jar, "uf", output, "META-INF")
        end

        [JavaInfo.new(
          jar: output,
          deps: java_info.deps,
        )]
      },
    )

    registry.new_rule(
      :java_runtime,
      attributes: {
        java: Attribute.new(Label, providers: [FileInfo]),
        libs: Attribute.new(Label, providers: [FileGroupInfo]),
      },
      implementation: ->(context, java:, libs:) {
        [JavaRuntimeInfo.new(
          java: java.fetch(FileInfo).path,
          libs: libs.fetch(FileGroupInfo).paths,
        )]
      },
    )

    registry.new_rule(
      :kotlin_compiler,
      attributes: {
        java_runtime: Attribute.new(Label, default: "//lib/java:runtime", providers: [JavaRuntimeInfo]),
        classpath: Attribute.new(Label, list: true, providers: [JavaInfo]),
        native: Attribute.new(Label, providers: [KotlinNativeCompilerInfo]),
      },
      implementation: ->(context, java_runtime:, classpath:, native:) {
        [
          KotlinJsCompilerInfo.new(
            java_runtime: java_runtime.fetch(JavaRuntimeInfo),
            classpath: classpath.map { |dep| dep.fetch(JavaInfo) },
          ),
          KotlinJvmCompilerInfo.new(
            java_runtime: java_runtime.fetch(JavaRuntimeInfo),
            classpath: classpath.map { |dep| dep.fetch(JavaInfo) },
          ),
          native.fetch(KotlinNativeCompilerInfo),
        ]
      },
    )

    registry.new_rule(
      :kotlin_native_compiler,
      attributes: {
        java_runtime: Attribute.new(Label, default: "//lib/java:runtime", providers: [JavaRuntimeInfo]),
        classpath: Attribute.new(Label, providers: [FileGroupInfo]),
        properties: Attribute.new(Label, providers: [FileInfo]),
        files: Attribute.new(Label, list: true, providers: [FileGroupInfo]),
      },
      implementation: ->(context, java_runtime:, classpath:, properties:, files:) {
        properties_orig = properties.fetch(FileInfo).path
        properties = context.expand_path("konan/konan.properties")

        context.run(
          inputs: [properties_orig],
          parameters: [],
          outputs: [properties],
        ) do |fs|
          fs.open(properties, "wb") do |dest|
            fs.open(properties_orig, "rb") do |src|
              src.each do |line|
                # TODO generalize this if we ever need to change more
                if line =~ /^airplaneMode *=/
                  dest.puts("airplaneMode = true")
                else
                  dest.write(line)
                end
              end
            end
          end
        end

        [KotlinNativeCompilerInfo.new(
          java_runtime: java_runtime.fetch(JavaRuntimeInfo),
          classpath: classpath.fetch(FileGroupInfo).paths,
          files: [properties, *files.map { |f| f.fetch(FileGroupInfo).paths }.flatten],
        )]
      },
    )

    registry.new_rule(
      :kt_js_lib,
      attributes: {
        kotlin_compiler: Attribute.new(Label, default: "//lib/kotlin:compiler", providers: [KotlinJsCompilerInfo]),
        srcs: Attribute.new(String, list: true),
        deps: Attribute.new(Label, list: true, default: [], providers: [KotlinJsInfo]),
        stdlib: Attribute.new(Label, default: "//lib/maven/org_jetbrains_kotlin/kotlin_stdlib_js:jar", providers: [KotlinJsInfo]),
        plugins: Attribute.new(Label, list: true, default: [], providers: [JavaInfo]),
      },
      implementation: ->(context, kotlin_compiler:, srcs:, deps:, stdlib:, plugins:) {
        compiler = kotlin_compiler.fetch(KotlinJsCompilerInfo)
        compiler.compile(srcs: srcs, deps: [stdlib, *deps], plugins: plugins, context: context)
      },
    )

    registry.new_rule(
      :kt_js_test,
      attributes: {
        kotlin_compiler: Attribute.new(Label, default: "//lib/kotlin:compiler", providers: [KotlinJsCompilerInfo]),
        srcs: Attribute.new(String, list: true),
        deps: Attribute.new(Label, list: true, default: ["//src/main/kotlin/wake/test:api_js", "//src/main/kotlin/wake/test:runtime_js"], providers: [KotlinJsInfo]),
        stdlib: Attribute.new(Label, default: "//lib/maven/org_jetbrains_kotlin/kotlin_stdlib_js:jar", providers: [KotlinJsInfo]),
        plugins: Attribute.new(Label, list: true, default: ["//src/main/kotlin/wake/test:plugin"], providers: [JavaInfo]),
        node_runtime: Attribute.new(Label, default: "//lib/node:runtime", providers: [NodeRuntimeInfo]),
      },
      implementation: ->(context, kotlin_compiler:, srcs:, deps:, stdlib:, plugins:, node_runtime:) {
        compiler = kotlin_compiler.fetch(KotlinJsCompilerInfo)

        test_modules = compiler.compile(
          srcs: srcs,
          deps: [stdlib, *deps],
          plugins: plugins,
          context: context,
        )

        node = node_runtime.fetch(NodeRuntimeInfo)
        test_module_js = test_modules.find(-> { raise }) { |provider| KotlinJsInfo === provider }.js

        [TestExecutableInfo.new(
          context: context,
          executable: node.node,
          runfiles: [test_module_js],
          arguments: [File.join(".", test_module_js)],
          env: { "NODE_PATH" => "." },
        )]
      },
    )

    registry.new_rule(
      :kt_jvm_lib,
      attributes: {
        kotlin_compiler: Attribute.new(Label, default: "//lib/kotlin:compiler", providers: [KotlinJvmCompilerInfo]),
        srcs: Attribute.new(String, list: true),
        deps: Attribute.new(Label, list: true, providers: [JavaInfo]),
        stdlib: Attribute.new(Label, default: "//lib/maven/org_jetbrains_kotlin/kotlin_stdlib:jar", providers: [JavaInfo]),
        plugins: Attribute.new(Label, list: true, default: [], providers: [JavaInfo]),
      },
      implementation: ->(context, kotlin_compiler:, srcs:, deps:, stdlib:, plugins:) {
        compiler = kotlin_compiler.fetch(KotlinJvmCompilerInfo)
        compiler.compile(srcs: srcs, deps: [stdlib, *deps], plugins: plugins, context: context)
      },
    )

    registry.new_rule(
      :kt_jvm_test,
      attributes: {
        kotlin_compiler: Attribute.new(Label, default: "//lib/kotlin:compiler", providers: [KotlinJvmCompilerInfo]),
        srcs: Attribute.new(String, list: true),
        deps: Attribute.new(Label, list: true, default: [], providers: [JavaInfo]),
        stdlib: Attribute.new(Label, default: "//lib/maven/org_jetbrains_kotlin/kotlin_stdlib:jar", providers: [JavaInfo]),
        plugins: Attribute.new(Label, list: true, default: [], providers: [JavaInfo]),
        java_runtime: Attribute.new(Label, default: "//lib/java:runtime", providers: [JavaRuntimeInfo]),
      },
      implementation: ->(context, kotlin_compiler:, srcs:, deps:, stdlib:, plugins:, java_runtime:) {
        compiler = kotlin_compiler.fetch(KotlinJvmCompilerInfo)
        test_library = compiler.compile(srcs: srcs, deps: [stdlib, *deps], plugins: plugins, context: context).find(-> { raise }) { |provider| JavaInfo === provider }

        jre = java_runtime.fetch(JavaRuntimeInfo)
        classpath = test_library.transitive_runtime_dependencies.flatten.sort.uniq

        [TestExecutableInfo.new(
          context: context,
          executable: jre.java,
          runfiles: jre.files.concat(classpath),
          arguments: [
            jre.arguments,
            "-cp", classpath.join(":"),
            "MainKt",
          ],
          env: {},
        )]
      },
    )

    registry.new_rule(
      :kotlin_js_import,
      attributes: {
        klib: Attribute.new(Label, providers: [FileInfo]),
      },
      implementation: ->(context, klib:) {
        [KotlinJsInfo.new(
          js: "", # FIXME what's going on here? What do we need?
          klib: klib.fetch(FileInfo).path,
          deps: [],
        )]
      },
    )

    registry.new_rule(
      :kotlin_native_import,
      attributes: {
        klib: Attribute.new(Label, providers: [FileInfo]),
      },
      implementation: ->(context, klib:) {
        [KotlinNativeInfo.new(
          klib: klib.fetch(FileInfo).path,
          deps: [],
        )]
      },
    )

    registry.new_rule(
      :kt_native_macos_lib,
      attributes: {
        kotlin_compiler: Attribute.new(Label, default: "//lib/kotlin:compiler", providers: [KotlinNativeCompilerInfo]),
        srcs: Attribute.new(String, list: true),
        deps: Attribute.new(Label, list: true, providers: [KotlinNativeInfo]),
        plugins: Attribute.new(Label, list: true, default: [], providers: [JavaInfo]),
      },
      implementation: ->(context, kotlin_compiler:, srcs:, deps:, plugins:) {
        compiler = kotlin_compiler.fetch(KotlinNativeCompilerInfo)
        compiler.compile(srcs: srcs, deps: deps, plugins: plugins, context: context)
      },
    )

    registry.new_rule(
      :kt_native_macos_test,
      attributes: {
        kotlin_compiler: Attribute.new(Label, default: "//lib/kotlin:compiler", providers: [KotlinNativeCompilerInfo]),
        srcs: Attribute.new(String, list: true),
        deps: Attribute.new(Label, list: true, default: [], providers: [KotlinNativeInfo]),
        plugins: Attribute.new(Label, list: true, default: [], providers: [JavaInfo]),
      },
      implementation: ->(context, kotlin_compiler:, srcs:, deps:, plugins:) {
        compiler = kotlin_compiler.fetch(KotlinNativeCompilerInfo)
        compiler.compile_test_binary(
          srcs: srcs,
          deps: deps,
          plugins: plugins,
          context: context,
        )
      },
    )

    registry.new_rule(
      :node_runtime,
      attributes: {
        node: Attribute.new(Label, providers: [FileInfo]),
      },
      implementation: ->(context, node:) {
        [NodeRuntimeInfo.new(
          node: node.fetch(FileInfo).path,
        )]
      },
    )

    registry.new_macro(
      :maven_jars,
      attributes: {
        repository: Attribute.new(URI, default: "https://repo1.maven.org/maven2"),
        artifacts: Attribute.new(MavenCoordinates, list: true),
      },
      implementation: ->(context, repository:, artifacts:) {
        # Here we want to resolve dependencies!
        artifacts.each do |artifact|
          context.package(artifact.package_path) do
            http_file(
              name: artifact.filename,
              url: artifact.url(repository),
              sha256: nil,
            )

            java_import(
              name: artifact.label_name,
              jar: artifact.filename,
            )
          end
        end
      },
    )

    registry.new_macro(
      :maven_js_klibs,
      attributes: {
        repository: Attribute.new(URI, default: "https://repo1.maven.org/maven2"),
        artifacts: Attribute.new(MavenCoordinates, list: true),
      },
      implementation: ->(context, repository:, artifacts:) {
        artifacts.each do |artifact|
          context.package(artifact.package_path) do
            http_file(
              name: artifact.filename,
              url: artifact.url(repository),
              sha256: nil,
            )

            kotlin_js_import(
              name: artifact.label_name,
              klib: artifact.filename,
            )
          end
        end
      },
    )

    registry.new_macro(
      :maven_native_klibs,
      attributes: {
        repository: Attribute.new(URI, default: "https://repo1.maven.org/maven2"),
        artifacts: Attribute.new(MavenCoordinates, list: true),
      },
      implementation: ->(context, repository:, artifacts:) {
        artifacts.each do |artifact|
          context.package(artifact.package_path) do
            http_file(
              name: artifact.filename,
              url: artifact.url(repository),
              sha256: nil,
            )

            kotlin_native_import(
              name: artifact.label_name,
              klib: artifact.filename,
            )
          end
        end
      },
    )
  end

  if Kernel.const_defined? :Minitest
    Test = Minitest::Test
  else
    Test = Object
  end

  class Context
    def initialize(filesystem, providers, label)
      @filesystem = filesystem
      @providers = providers
      @label = label
    end

    def invoke(rule, config, attributes)
      # TODO do we want rules to register providers more explicitly?
      @providers[@label] = rule.call(Actions.new(@label, @filesystem, **config.using(@providers)), **attributes.using(@providers)) || []
    end
  end

  class Actions
    def initialize(label, filesystem, **config)
      @label = label
      @filesystem = filesystem
      @config = config
    end

    def debug?
      @config[:debug]
    end

    def expand_path(path)
      File.join(@label.package, path.gsub("%{name}", @label.name))
    end

    def run(inputs: [], parameters: [], outputs:, &block)
      alien = outputs.reject { |path| path.start_with?(@label.package) }
      raise "Action for #{@label} cannot produce outputs outside of #{@label.package}, but claims #{alien}." if alien.any?

      key = Digest::SHA256.hexdigest("#{@label}-#{inputs.map { |path| checksum(path) }.join("-")}-#{parameters.join("-")}-#{outputs.join("-")}")

      if @config[:debug] || @config[:verbose] || !@filesystem.exists?("var/cache/#{key}")
        @filesystem.mktmpdir do |dir|
          inputs.each do |path|
            if @filesystem.exists?(path)
              @filesystem.link(path, "#{dir}/#{path}")
            else
              @filesystem.link("var/tmp/#{path}", "#{dir}/#{path}")
            end
          end

          block.call(@filesystem.sandbox(dir, **@config))

          missing = outputs.reject { |path| @filesystem.exists?("#{dir}/#{path}") }
          raise "Action for #{@label} failed to produce outputs #{missing}." if missing.any?

          outputs.each do |path|
            @filesystem.link("#{dir}/#{path}", "var/cache/#{key}/#{path}")
          end
        end
      end

      outputs.each do |path|
        @filesystem.link("var/cache/#{key}/#{path}", "var/tmp/#{path}")
      end
    end

    private

    def checksum(path)
      if @filesystem.exists?(path)
        @filesystem.checksum(path)
      else
        @filesystem.checksum("var/tmp/#{path}")
      end
    end
  end

  class ActionsTest < Test
    def setup
      @files = {}
      @filesystem = InMemoryFilesystem.new("/workspace", @files)
    end

    def test_run_caching
      @files["/workspace/src/foo.txt"] = "FOO"
      @files["/workspace/src/bar.txt"] = "BAR"

      Actions.new(Label["//src:baz"], @filesystem).run(outputs: ["src/baz.out"]) do |fs|
        fs.open("src/baz.out", "w") { |io| io.puts("BAZ") }
      end

      Actions.new(Label["//src:foo"], @filesystem).run(inputs: ["src/foo.txt", "src/bar.txt", "src/baz.out"], outputs: ["src/foo.out"]) do |fs|
        fs.open("src/foo.out", "w") do |io|
          2.times { fs.open("src/foo.txt", "r") { |foo| io.puts(foo.read) } }
          2.times { fs.open("src/bar.txt", "r") { |bar| io.puts(bar.read) } }
          2.times { fs.open("src/baz.out", "r") { |baz| io.puts(baz.read) } }
        end
      end

      assert_equal(<<~END, @files.fetch("/workspace/var/tmp/src/foo.out"))
        FOO
        FOO
        BAR
        BAR
        BAZ
        BAZ
      END

      # nothing changes (re-run with raising block?)
      Actions.new(Label["//src:foo"], @filesystem).run(inputs: ["src/foo.txt", "src/bar.txt", "src/baz.out"], outputs: ["src/foo.out"]) do |fs|
        raise "Shouldn't get here!"
      end

      # source changes
      @files["/workspace/src/foo.txt"] = "FOOFOO"

      Actions.new(Label["//src:foo"], @filesystem).run(inputs: ["src/foo.txt", "src/bar.txt", "src/baz.out"], outputs: ["src/foo.out"]) do |fs|
        fs.open("src/foo.out", "w") do |io|
          2.times { fs.open("src/foo.txt", "r") { |foo| io.puts(foo.read) } }
          2.times { fs.open("src/bar.txt", "r") { |bar| io.puts(bar.read) } }
          2.times { fs.open("src/baz.out", "r") { |baz| io.puts(baz.read) } }
        end
      end

      assert_equal(<<~END, @files.fetch("/workspace/var/tmp/src/foo.out"))
        FOOFOO
        FOOFOO
        BAR
        BAR
        BAZ
        BAZ
      END

      # generated changes
      Actions.new(Label["//src:baz"], @filesystem).run(parameters: [:changed], outputs: ["src/baz.out"]) do |fs|
        fs.open("src/baz.out", "w") { |io| io.puts("BAZBAZ") }
      end

      Actions.new(Label["//src:foo"], @filesystem).run(inputs: ["src/foo.txt", "src/bar.txt", "src/baz.out"], outputs: ["src/foo.out"]) do |fs|
        fs.open("src/foo.out", "w") do |io|
          2.times { fs.open("src/foo.txt", "r") { |foo| io.puts(foo.read) } }
          2.times { fs.open("src/bar.txt", "r") { |bar| io.puts(bar.read) } }
          2.times { fs.open("src/baz.out", "r") { |baz| io.puts(baz.read) } }
        end
      end

      assert_equal(<<~END, @files.fetch("/workspace/var/tmp/src/foo.out"))
        FOOFOO
        FOOFOO
        BAR
        BAR
        BAZBAZ
        BAZBAZ
      END
    end
  end

  class InMemoryFilesystem
    def initialize(base, files)
      @base = base
      @files = files
    end

    def checksum(path)
      # A real filesystem would do some caching here, since these are expensive.
      Digest::SHA256.hexdigest(@files.fetch(absolute_path(path)))
    end

    def exists?(path)
      # First clause is for files.
      # Second clause is a hack for directories, since we're not modeling them fully, just putting path -> contents in a Hash.
      path = absolute_path(path)
      @files.key?(path) || @files.keys.any? { |candidate| candidate.start_with?(path) && candidate[path.length] == "/" }
    end

    def link(src, dest)
      @files[absolute_path(dest)] = @files.fetch(absolute_path(src))
    end

    def mktmpdir(&block)
      tmp = "/tmp/#{Time.now.strftime("%Y%m%d")}-#{$$}-#{rand(0x100000000).to_s(36)}"
      yield tmp
    ensure
      @files.delete_if { |path, content| path.start_with?(tmp) }
    end

    def sandbox(base, **config)
      Sandbox.new(absolute_path(base), @files)
    end

    private

    def absolute_path(path)
      path.start_with?("/") ? path : "#{@base}/#{path}"
    end

    class Sandbox
      def initialize(base, files)
        @base = base
        @files = files
      end

      def open(path, mode, permissions: 0644, &block)
        case mode
        when "r"
          yield StringIO.new(@files.fetch(File.join(@base, path)))
        when "w"
          io = StringIO.new
          yield io
          @files[File.join(@base, path)] = io.string
        else
          raise "Unsupported mode #{mode}"
        end
      end

      def exec!(*args)
        raise "InMemoryFilesystem::Sandbox doesn't support exec!"
      end

      def mktmpdir(&block)
        raise "InMemoryFilesystem::Sandbox doesn't support mktmpdir!"
      end
    end
  end

  class RealFilesystem
    def initialize(base)
      @base = base
      path = absolute_path("var/run/filesystem.yml")
      cache = Psych.load_file(path) rescue Hash.new
      @checksums = cache.fetch(:checksums, {})
      @mtimes = cache.fetch(:mtimes, {})
      @mutex = Mutex.new
      at_exit {
        cache = { checksums: @checksums, mtimes: @mtimes }
        FileUtils.mkdir_p(File.dirname(path))
        File.open(path, "wb") { |io| Psych.dump(cache, io) }
      }
    end

    def checksum(path)
      path = absolute_path(path)

      # TODO if these stats get expensive, maybe we eagerly cache checksums for
      # generated files and take a separate path for "volatile" source files.
      mtime = File.mtime(path)

      @mutex.synchronize do
        if @mtimes.key?(path) && @mtimes[path] == mtime
          @checksums.fetch(path)
        else
          @mtimes[path] = mtime
          @checksums[path] = Digest::SHA256.file(path).hexdigest
        end
      end
    end

    def exists?(path)
      path = absolute_path(path)
      File.exist?(path)
    end

    def link(src, dest)
      src = absolute_path(src)
      dest = absolute_path(dest)
      FileUtils.mkdir_p(File.dirname(dest))
      FileUtils.ln(src, dest, force: true)
    end

    def purge(path, before:)
      path = absolute_path(path)

      Find.find(path).
        map { |p| [p, File.stat(p)] }.
        select { |p, stat| stat.file? }.
        select { |p, stat| stat.mtime < before }.
        select { |p, stat| stat.nlink == 1 }.
        each { |p, stat| FileUtils.remove_entry(p) }

      Find.find(path).
        select { |p| File.directory?(p) }.
        sort.
        reverse_each { |p| FileUtils.remove_entry(p) if Dir.empty?(p) }
    end

    def mktmpdir(&block)
      Dir.mktmpdir(&block)
    end

    def sandbox(base, **config)
      Sandbox.new(self, absolute_path(base), **config)
    end

    private

    def absolute_path(path)
      path.start_with?("/") ? path : "#{@base}/#{path}"
    end

    class Sandbox
      def initialize(fs, base, **config)
        @fs = fs
        @base = base
        @config = config
      end

      def open(path, mode, permissions: 0644, &block)
        path = File.join(@base, path)
        FileUtils.mkdir_p(File.dirname(path))
        File.open(path, mode, permissions) { |io| io.sync = true; block.call(io) }
      end

      def exec!(*args, out: StringIO.new, err: StringIO.new, env: {})
        spy_out = StringIO.new
        spy_err = StringIO.new

        if @config[:verbose]
          out = CompositeIO.new(out, spy_out, $stdout)
          err = CompositeIO.new(err, spy_err, $stderr)
        else
          out = CompositeIO.new(out, spy_out)
          err = CompositeIO.new(err, spy_err)
        end

        initial_files = Find.find(@base).
          reject { |path| File.directory?(path) }.
          map { |path| path[@base.length + 1, path.length - 1] }

        args = args.flatten.map { |a| a.gsub("%{pwd}", @base) }
        env = env.map { |k, v| [k, v.gsub("%{pwd}", @base)] }.to_h
        status = exec(*args, out: out, err: err, env: env)

        if !status.success?
          files = Find.find(@base).
            reject { |path| File.directory?(path) }.
            map { |path| path[@base.length + 1, path.length - 1] }
          raise ExecutionError.new(args: args, status: status, out: spy_out.string, err: spy_err.string, env: env, pwd: @base, files: files, initial_files: initial_files)
        end
      end

      def mktmpdir(&block)
        @fs.mktmpdir(&block)
      end

      private

      def exec(*args, out: StringIO.new, err: StringIO.new, env: {})
        o, e, s = Open3.capture3(env, *args.flatten, chdir: @base, unsetenv_others: true)
        out.write(o)
        err.write(e)
        s
      end

      class ExecutionError < RuntimeError
        attr_reader :status
        attr_reader :out
        attr_reader :err
        attr_reader :env

        def initialize(args:, status:, out:, err:, env:, pwd:, files:, initial_files:)
          @args = args
          @status = status
          @out = out
          @err = err
          @env = env
          @files = files

          added_files = (@files.to_set - initial_files.to_set).to_a

          super(<<~END)
            Commmand exited with status #{status.exitstatus}.

            COMMAND:
            #{Shellwords.join(args)}

            ENV:
            #{env.map { |k, v| "#{k}=#{v}" }.join("\n")}

            PWD:
            #{pwd}

            FILES:
            #{files.sort.join("\n")}

            ADDED FILES:
            #{added_files.sort.join("\n")}

            OUT:
            #{out.strip}

            ERR:
            #{err.strip}
          END
        end
      end
    end
  end

  class RealFilesystemTest < Test
    def setup; @tmp = Dir.mktmpdir; end
    def teardown; FileUtils.remove_entry(@tmp); end

    def test_exec
      fs = RealFilesystem.new(@tmp)
      sandbox = fs.sandbox("sandbox")
      sandbox.open("foo.txt", "wb") do |io|
        sandbox.exec!("bash", "-c", "echo hi", out: io)
      end
      assert_equal "hi\n", File.read(File.join(@tmp, "sandbox", "foo.txt"))
    end

    def test_exec_raises
      fs = RealFilesystem.new(@tmp)
      sandbox = fs.sandbox("sandbox")
      # We don't care what happens to the file (was it partially written?)
      # because we're typically making sandboxes in tmpdirs that get thrown
      # away anyway.
      sandbox.open("foo.txt", "wb") do |io|
        error = assert_raises(Wake::RealFilesystem::Sandbox::ExecutionError) do
          sandbox.exec!("bash", "-c", "echo hi; false", out: io)
        end
        assert_equal "hi\n", error.out
        assert_equal "", error.err
      end
    end
  end

  class ProviderRegistry
    class MissingLabelError < KeyError
      def initialize(label)
        super "#{label} has not been seen"
      end
    end

    class MissingProviderError < KeyError
      def initialize(label, type)
        super "#{label} does not provide #{type}"
      end
    end

    def initialize
      @providers = {}
      @mutex = Mutex.new
    end

    def [](label, types)
      @providers.fetch(label) { raise MissingLabelError.new(label) }.slice(types)
    end

    def []=(label, providers)
      @mutex.synchronize do
        @providers[label] = Holder.new(label, providers)
      end
    end

    def of(type)
      @providers.
        select { |label, providers| providers.key?(type) }.
        map { |label, providers| [label, providers.fetch(type)] }.
        to_h
    end

    private

    class Holder
      def initialize(label, providers)
        @label = label
        @providers = providers.map { |instance| [instance.class, instance] }.to_h.freeze
      end

      def fetch(type)
        @providers.fetch(type) { raise MissingProviderError.new(@label, type) }
      end

      def key?(type)
        @providers.key?(type)
      end

      def slice(types)
        Holder.new(@label, @providers.fetch_values(*types) { |missing| raise MissingProviderError.new(@label, missing) })
      end
    end
  end

  class ProviderRegistryTest < Test
    def setup
      @registry = ProviderRegistry.new
      @label = Label["//src/main:foo"]
      @type = Class.new
      @instance = @type.new
    end

    def test_happy_path
      @registry[@label] = [@instance]
      assert_equal @instance, @registry[@label, [@type]].fetch(@type)
    end

    def test_upstream_does_not_exist
      assert_raises(ProviderRegistry::MissingLabelError) do
        @registry[@label, [@type]]
      end
    end

    def test_upstream_does_not_provide
      @registry[@label] = []
      assert_raises(ProviderRegistry::MissingProviderError) do
        @registry[@label, [@type]]
      end
    end

    def test_current_does_not_depend
      @registry[@label] = [@instance]
      providers = @registry[@label, []]
      assert_raises(ProviderRegistry::MissingProviderError) do
        providers.fetch(@type)
      end
    end
  end

  class Verifier
    def self.parse(checksum)
      Verifier.new(Digest::SHA256, checksum: checksum)
    end

    def initialize(digest, checksum: nil, observer: ->(measured_checksum) { })
      @digest = digest
      @expected_checksum = checksum
      @observer = observer
    end

    def checksum
      @expected_checksum
    end

    def observing(&observer)
      Verifier.new(@digest, checksum: @expected_checksum, observer: observer)
    end

    def wrapping(path, io, &block)
      digest = @digest.new
      block.call(Wrapper.new(io, digest))
      measured_checksum = digest.hexdigest
      if @expected_checksum
        raise "Expected #{@expected_checksum} for #{path} but got #{measured_checksum}" if @expected_checksum != measured_checksum
      else
        @observer.call(measured_checksum)
      end
    end

    private

    class Wrapper
      def initialize(io, digest)
        @io = io
        @digest = digest
      end

      def write(content)
        @digest.update(content)
        @io.write(content)
      end
    end
  end

  class Platform
    def initialize(host_os:)
      @host_os = host_os
    end

    def compatible_with?(os:)
      os == :any || os == host_os
    end

    private

    def host_os
      case @host_os
      when /darwin/
        :macos
      when /linux/
        :linux
      end
    end
  end

  class PlatformTest < Test
    def test_host_os_darwin_any
      assert Platform.new(host_os: "darwin19").compatible_with?(os: :any)
    end

    def test_host_os_darwin_linux
      assert !Platform.new(host_os: "darwin19").compatible_with?(os: :linux)
    end

    def test_host_os_darwin_macos
      assert Platform.new(host_os: "darwin19").compatible_with?(os: :macos)
    end

    def test_host_os_linux_any
      assert Platform.new(host_os: "i686-linux").compatible_with?(os: :any)
    end

    def test_host_os_linux_linux
      assert Platform.new(host_os: "i686-linux").compatible_with?(os: :linux)
    end

    def test_host_os_linux_macos
      assert !Platform.new(host_os: "i686-linux").compatible_with?(os: :macos)
    end
  end

  class Registry
    def initialize
      @dsl = Class.new(Dsl)
      @targets = {}
      @toolchains = []
      @toolchain_types = {}
    end

    def new_package(package)
      @dsl.new(registry: self, package: package)
    end

    def new_rule(rule_name, attributes: {}, implementation: ->(context, **attributes) { })
      schema = AttributeSchema.new(attributes)

      @dsl.class_eval(<<~END)
        def #{rule_name}(#{[Target::COMMON.dsl_method_parameters, schema.dsl_method_parameters].reject(&:empty?).join(", ")})
          __#{rule_name}(#{[Target::COMMON.dsl_method_forwarding_parameters, schema.dsl_method_forwarding_parameters].reject(&:empty?).join(", ")})
        end
      END

      @dsl.define_method("__#{rule_name}") do |**attributes|
        @registry.new_target(
          label: Label.new(package: @package, name: attributes.fetch(:name)),
          rule: implementation,
          common: Target::COMMON.parse(attributes, package: @package),
          attributes: schema.parse(attributes, package: @package),
        )
      end

      @dsl.class_eval("private :__#{rule_name}")
    end

    def new_target(label:, rule:, common:, attributes:)
      @targets[label] = Target.new(rule: rule, common: common, attributes: attributes)
    end

    def new_toolchain_type(package:, name:, providers:)
      @toolchain_types[Label.new(package: package, name: name)] = providers
    end

    def new_toolchain(package:, name:, os:, toolchain:, toolchain_type:)
      @toolchains << Toolchain.new(
        name: name,
        os: os,
        toolchain: Label.parse(toolchain, package: package),
        toolchain_type: Label.parse(toolchain_type, package: package),
      )
    end

    def new_macro(macro_name, attributes: {}, implementation: ->(context, **attributes) { })
      schema = AttributeSchema.new(attributes)

      @dsl.class_eval(<<~END)
        def #{macro_name}(#{schema.dsl_method_parameters})
          __#{macro_name}(#{schema.dsl_method_forwarding_parameters})
        end
      END

      @dsl.define_method("__#{macro_name}") do |**attributes|
        @registry.expand_macro(
          package: @package,
          macro: implementation,
          attributes: schema.parse(attributes, package: @package),
        )
      end

      @dsl.class_eval("private :__#{macro_name}")
    end

    def expand_macro(package:, macro:, attributes:)
      macro.call(MacroContext.new(registry: self, package: package), **attributes)
    end

    def resolve(platform:)
      result = @targets.select { |label, target| target.compatible_with?(platform) }

      # TODO lazily include toolchains as we will repository targets!
      # So, don't bother with //lib/java:compiler unless one of my targets depends on it.
      @toolchains.select { |toolchain| toolchain.compatible_with?(platform) }.each do |toolchain|
        providers = @toolchain_types.fetch(toolchain.toolchain_type)

        result[toolchain.toolchain_type] = Target.new(
          common: Target::COMMON.parse({ name: toolchain.name, os: toolchain.os }),
          attributes: AttributeSchema.new(
            actual: Attribute.new(Label, providers: providers),
          ).parse({
            actual: toolchain.toolchain,
          }),
          rule: ->(context, actual:) {
            providers.map { |provider| actual.fetch(provider) }
          },
        )
      end

      result.freeze
    end

    private

    class Dsl
      def initialize(registry:, package:)
        @registry = registry
        @package = package
      end

      def toolchain_type(name:, providers: [])
        @registry.new_toolchain_type(package: @package, name: name, providers: providers)
      end

      def toolchain(name:, os:, toolchain:, toolchain_type:)
        @registry.new_toolchain(package: @package, name: name, os: os, toolchain: toolchain, toolchain_type: toolchain_type)
      end
    end

    class MacroContext
      def initialize(registry:, package:)
        @registry = registry
        @package = package
      end

      def package(name, &block)
        @registry.new_package([@package, name].join("/")).instance_exec(&block)
      end
    end

    class Toolchain < Struct.new(:name, :os, :toolchain, :toolchain_type, keyword_init: true)
      def compatible_with?(platform)
        platform.compatible_with?(os: os)
      end
    end
  end

  class RegistryTest < Test
    def test_platform_constraints_for_toolchains
      registry = Registry.new

      registry.new_rule(:foo_compiler)

      registry.new_macro(
        :foo_compiler_package,
        attributes: {
          name: Attribute.new(String),
        },
        implementation: ->(context, name:) {
          context.package(name) {
            foo_compiler(name: "compiler")
          }
        },
      )

      registry.new_package("foo").instance_exec do
        toolchain_type(name: "compiler")

        foo_compiler_package(name: "linux")
        foo_compiler_package(name: "macos")

        toolchain(
          name: "compiler_linux",
          os: :linux,
          toolchain: "//foo/linux:compiler",
          toolchain_type: "//foo:compiler",
        )

        toolchain(
          name: "compiler_macos",
          os: :macos,
          toolchain: "//foo/macos:compiler",
          toolchain_type: "//foo:compiler",
        )
      end

      linux_targets = registry.resolve(
        platform: Platform.new(host_os: "i686-linux"),
      )

      macos_targets = registry.resolve(
        platform: Platform.new(host_os: "darwin19"),
      )

      assert_equal Set[Label["//foo/linux:compiler"]],
        linux_targets[Label["//foo:compiler"]].dependencies

      assert_equal Set[Label["//foo/macos:compiler"]],
        macos_targets[Label["//foo:compiler"]].dependencies
    end
  end

  class Console
    def initialize(io)
      @events = Queue.new
      @renderings = Queue.new

      cols = io.tty? ? io.winsize[1] : 80

      @ticker = Thread.new do
        while true
          @events << [:tick, Process.clock_gettime(Process::CLOCK_MONOTONIC)]
          sleep 0.1
        end
      end

      @renderer = Thread.new(cols) do |cols|
        time = Process.clock_gettime(Process::CLOCK_MONOTONIC)
        targets = []
        progress = {}
        test_results = []
        arbitrary_output = []

        while event = @events.pop
          case event.first
          when :arbitrary_output
            arbitrary_output << event[1..-1]
          when :progress
            progress[event[1]] = event[2]
          when :target_invocation
            targets << { label: event.last, started_at: time }
          when :target_completion
            targets.delete_if { |target| target.fetch(:label) == event.last }
          when :test_result
            test_results << event.last
          when :tick
            time = event.last
          end

          @renderings << View.new(
            time: time,
            targets: targets,
            progress: progress,
            test_results: test_results,
            arbitrary_output: arbitrary_output,
          ).format(cols: cols)
        end
      end

      @blatter = Thread.new(io, cols) do |io, cols|
        previous = ""

        while buffer = @renderings.pop
          if buffer != previous
            io.write AnsiRendering.new(from: WrappedAnsiString.new(previous, cols: cols).to_s, to: WrappedAnsiString.new(buffer, cols: cols).to_s)
            io.flush
            previous = buffer
          end
        end
      end
    end

    def join
      @ticker.exit
      @events.close
      @renderer.join
      @renderings.close
      @blatter.join
    end

    def write(*args)
      @events << [:arbitrary_output, *args]
      args.join.length
    end

    def puts(*args)
      write(*args.
        map(&:to_s).
        map(&:chomp).
        map { |a| a.concat("\n") })
    end

    def flush
      # no-op for now; all ops redraw
    end

    def report_target_invocation(label)
      @events << [:target_invocation, label]
    end

    def report_target_completion(label)
      @events << [:target_completion, label]
    end

    def report_progress(label, percentage)
      @events << [:progress, label, percentage]
    end

    def report_test_result(result)
      @events << [:test_result, result]
    end

    private

    class View
      def initialize(time:, targets:, progress:, test_results:, arbitrary_output:)
        @time = time.freeze
        @targets = targets.dup.freeze
        @progress = progress.select { |label, progress| progress < 100 }.dup.freeze
        @test_results = test_results.dup.freeze
        @arbitrary_output = arbitrary_output.dup.freeze
      end

      def format(cols:)
        buffer = StringIO.new

        if @targets.any?
          @targets.each do |target|
            label = target.fetch(:label)
            running_time = @time - target.fetch(:started_at)
            buffer.puts "%s %ds" % [label, running_time]
          end
          buffer.puts
        end

        if @progress.any?
          format = "%s |%s%s| %2d%%"
          @progress.each do |label, percentage|
            total_cols = cols - (format % [label, "", "", percentage]).length
            bar_cols = (percentage * total_cols / 100.0).floor
            space_cols = total_cols - bar_cols
            buffer.puts format % [label, "=" * bar_cols, " " * space_cols, percentage]
          end
          buffer.puts
        end

        if @test_results.any?
          # BIG BAR
          # buffer.print("\e[7;%sm" % [@test_results.max.ansi_color_code])
          # buffer.print " " * @test_results.count
          # buffer.puts "\e[0m"
          # buffer.puts

          # LITTLE DOTS
          buffer.puts @test_results.map { |result| "\e[%sm%s\e[0m" % [result.ansi_color_code, result.result_code] }.join
          buffer.puts

          @test_results.reject(&:passed?).each_with_index do |result, i|
            buffer.puts "\e[%sm%3d) %s:\n%s\e[0m" % [result.ansi_color_code, i + 1, result.result_label, result]
            buffer.puts
          end
        end

        if @arbitrary_output.any?
          @arbitrary_output.each do |args|
            buffer.write(*args)
          end

          buffer.puts
        end

        buffer.string
      end
    end
  end

  class WrappedAnsiString
    def initialize(string, cols:)
      @scanner = StringScanner.new(string)
      @wrapped = ""
      @terminal_width = cols
    end

    def to_s
      until @scanner.eos?
        if text = @scanner.scan(/[^\e]+/)
          process_plain_text(text)
        elsif sgr_sequence = @scanner.scan(/\e\[.*?m/)
          process_escape_code(sgr_sequence)
        else
          raise "Unhandled escape code! WRAPPED:#{@wrapped} REST:#{@scanner.rest}"
        end
      end

      @wrapped
    end

    private

    def process_plain_text(text)
      text.lines.each { |line| process_plain_text_line(line) }
    end

    def process_plain_text_line(line)
      if line.chomp.length > @terminal_width
        process_plain_text_line_wrapping(line)
      else
        @wrapped << line
      end
    end

    def process_plain_text_line_wrapping(line)
      scanner = StringScanner.new(line)
      pos = 0
      until scanner.eos?
        if chars = scanner.scan(/[^\n]{1,#{@terminal_width - pos}}/)
          @wrapped << chars
          pos += chars.length
          if @terminal_width == pos && scanner.check(/[^\n]/)
            @wrapped << "\n"
            pos = 0
          end
        elsif scanner.scan(/\n/)
          @wrapped << "\n"
          pos = 0
        else
          raise "What happened? #{scanner.rest}"
        end
      end
    end

    def process_escape_code(escape_code)
      @wrapped << escape_code
    end
  end

  class WrappedAnsiStringTest < Test
    def test_limit
      assert_equal "100%\n", WrappedAnsiString.new("100%\n", cols: 4).to_s
    end
  end

  class AnsiRendering
    def initialize(from:, to:)
      @rows = to.lines.zip(from.lines)
      @from_row_count = from.lines.count
    end

    def to_s
      result = ""

      if @from_row_count > 0
        result << "\e[#{@from_row_count}F"
      end

      @rows.each do |to, from|
        if to != from
          # TODO could do something fancy with diff editing, but cursor
          # movements again get tricky given ANSI escape sequences
          result << to.chomp
          result << "\e[K" if to.chomp.length < from.to_s.chomp.length
          result << "\n"
        else
          result << "\e[E"
        end
      end

      result << "\e[J"

      result
    end
  end

  class AnsiRenderingTest < Test
    def test_limit
      assert_equal "\e[1F80%\n\e[J", AnsiRendering.new(from: "79%", to: "80%").to_s
    end
  end

  # TODO connection pool?
  # TODO worker pool?
  # TODO "integration" test?
  class HttpDownloader
    def initialize(console = nil)
      @console = console
    end

    def get(url, io, original: url)
      http = Net::HTTP.new(url.hostname, url.port)
      http.use_ssl = true

      if http.proxy? # TODO figure out self-signed cert handling for local caching squid installation
        http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      end

      http.start do |http|
        http.request_get(url) do |response|
          case response
          when Net::HTTPSuccess
            response.read_body(CompositeIO.new(io, Progress.new(@console, original, response["content-length"].to_i)))
          when Net::HTTPRedirection
            get(URI.parse(response["location"]), io, original: original)
          when Net::HTTPNotFound
            raise "404 #{url}"
          else
            response.error!
          end
        end
      end
    end

    private

    class Progress
      def initialize(console, url, total)
        @console = console
        @label = url.path.split("/").last
        @total = total
        @current = 0
      end

      def write(chunk)
        @current += chunk.size
        @console.report_progress(@label, (@current * 100.0 / @total).floor)
        chunk.size
      end
    end
  end

  class CompositeIO
    def initialize(*ios)
      @ios = ios
    end

    def write(*args)
      # TODO this gets hinky when the answers are different!
      @ios.map { |io| io.write(*args) }.max
    end

    def <<(*args)
      write(*args)
    end
  end

  # Struct saves the boilerplate of making Label work as a Hash key.
  class Label < Struct.new(:package, :name, keyword_init: true)
    def self.[](string)
      parse(string)
    end

    def self.parse(string, package: nil)
      head, rest = string.split(":", 2)

      if head.start_with? "//"
        parsed_package = head[2..-1]
        parsed_name = rest
      elsif rest
        parsed_package = package
        parsed_name = rest
      else
        parsed_package = package
        parsed_name = head
      end

      if parsed_package.nil? || parsed_name.nil?
        raise "Invalid label: #{string.inspect}"
      end

      Label.new(package: parsed_package, name: parsed_name).freeze
    end

    def inspect
      "#<label #{to_s}>"
    end

    def to_s
      "//#{package}:#{name}"
    end
  end

  class LabelTest < Test
    def test_parse
      label = Label.parse("//src/main:foo")
      assert_equal "src/main", label.package
      assert_equal "foo", label.name
    end

    def test_parse_without_name
      assert_raises { Label.parse("//src/main") }
    end

    def test_parse_relative
      label = Label.parse(":foo", package: "src/main")
      assert_equal "src/main", label.package
      assert_equal "foo", label.name
    end

    def test_parse_relative_without_package
      assert_raises { Label.parse(":foo") }
    end

    def test_parse_filename
      label = Label.parse("foo.kt", package: "src/main")
      assert_equal "src/main", label.package
      assert_equal "foo.kt", label.name
    end
  end

  class AttributeSchema
    def initialize(fields = {})
      @fields = fields
    end

    def dependencies(values)
      @fields.map { |name, type| type.dependencies(values.fetch(name)) }.reduce(Set.new, &:merge).freeze
    end

    def dsl_method_parameters
      @fields.map { |name, type| type.as_method_parameter(name) }.join(", ")
    end

    def dsl_method_forwarding_parameters
      @fields.keys.map { |name| "#{name}: #{name}" }.join(", ")
    end

    def parse(raw, **options)
      Attributes.new(self, values(raw, **options))
    end

    def using(providers, values)
      @fields.map { |name, type| [name, type.using(providers, values.fetch(name))] }.to_h.freeze
    end

    private

    def values(raw, **options)
      @fields.map { |name, type| [name, type.parse(raw[name], **options)] }.to_h.freeze
    end
  end

  class AttributeSchemaTest < Test
    def setup
      @schema = AttributeSchema.new(
        deps: Attribute.new(Label, list: true),
        compiler: Attribute.new(Label, default: "//lib:compiler"),
        strip_components: Attribute.new(PathCleaner, default: 0),
        build: Attribute.new(Proc, default: ->() { }),
        neverlink: Attribute.new(TrueClass, default: false),
      )
    end

    def test_dsl_method_parameters
      assert_equal "deps:, compiler: \"//lib:compiler\", strip_components: 0, build: ->() { }, neverlink: false",
        @schema.dsl_method_parameters
    end

    def test_dsl_method_forwarding_parameters
      assert_equal "deps: deps, compiler: compiler, strip_components: strip_components, build: build, neverlink: neverlink",
        @schema.dsl_method_forwarding_parameters
    end
  end

  class Attributes
    def initialize(schema, values)
      @schema = schema
      @values = values
    end

    def dependencies
      @schema.dependencies(@values)
    end

    def using(providers)
      @schema.using(providers, @values)
    end

    def to_hash
      @values
    end
  end

  class Attribute
    def initialize(type, list: false, default: nil, providers: [])
      @type = type
      @list = list
      @default = default
      @providers = providers
    end

    def as_method_parameter(name)
      !@default.nil? ? "#{name}: #{@type == Proc ? "->() { }" : @default.inspect}" : "#{name}:"
    end

    def dependencies(value)
      @type == Label ? (@list ? Set.new(value) : Set.new([value])) : Set.new
    end

    def parse(raw_value, **options)
      if @list
        Array(raw_value || @default).map { |item| try_parse(item, **options) }.freeze
      else
        try_parse(raw_value || @default, **options).freeze
      end
    end

    def using(providers, value)
      if @type == Label && !@list
        providers[value, @providers]
      elsif @type == Label && @list
        value.map { |v| providers[v, @providers] }
      else
        value
      end
    end

    private

    def try_parse(raw_value, **options)
      if @type === raw_value
        raw_value
      elsif @type == Label
        @type.parse(raw_value, **options)
      elsif @type == TrueClass && raw_value == false
        raw_value
      else
        @type.parse(raw_value)
      end
    end
  end

  class AttributeTest < Test
    def test_parse
      assert_equal URI.parse("https://example.com"), Attribute.new(URI).parse("https://example.com")
      assert Attribute.new(TrueClass).parse(true)
    end

    def test_parse_already_parsed
      assert_equal URI.parse("https://example.com"), Attribute.new(URI).parse(URI.parse("https://example.com"))
    end

    def test_parse_default
      assert_equal URI.parse("https://example.com"), Attribute.new(URI, default: "https://example.com").parse(nil)
      assert Attribute.new(TrueClass, default: true).parse(nil)
      assert !Attribute.new(TrueClass, default: false).parse(nil)
    end

    def test_parse_nil_no_default
      # TODO make the error messages better. Requires attribute to know or be passed its name, which we're not doing yet.
      assert_raises { Attribute.new(Label).parse(nil) }
      assert_raises { Attribute.new(MavenCoordinates).parse(nil) }
      assert_raises { Attribute.new(String).parse(nil) }
      assert_raises { Attribute.new(TrueClass).parse(nil) }
      assert_raises { Attribute.new(URI).parse(nil) }
    end

    def test_parse_list
      assert_equal [URI.parse("https://example.com")], Attribute.new(URI, list: true).parse(["https://example.com"])
    end

    def test_parse_list_single
      assert_equal [URI.parse("https://example.com")], Attribute.new(URI, list: true).parse("https://example.com")
    end

    def test_parse_list_empty
      assert_equal [], Attribute.new(URI, list: true).parse(nil)
    end

    def test_parse_relative_label
      assert_equal Label["//src/main:foo"], Attribute.new(Label).parse(":foo", package: "src/main")
    end
  end

  class Target
    COMMON = AttributeSchema.new(
      name: Attribute.new(String),
      os: Attribute.new(Symbol, default: :any),
      verbose: Attribute.new(TrueClass, default: false),
      debug: Attribute.new(TrueClass, default: false),
    )

    def initialize(rule:, common:, attributes:)
      @rule = rule
      @common = common
      @attributes = attributes
    end

    def compatible_with?(platform)
      platform.compatible_with?(os: @common.to_hash.fetch(:os))
    end

    def dependencies
      @attributes.dependencies
    end

    def invoke(context)
      context.invoke(@rule, @common, @attributes)
    end
  end

  class TargetTest < Test
    def test_dependencies
      target = Target.new(
        rule: ->(context, **attributes) { },
        common: Target::COMMON.parse({ name: "foo" }),
        attributes: AttributeSchema.new(
          thing: Attribute.new(Label),
          things: Attribute.new(Label, list: true),
          irrelevant_things: Attribute.new(String, list: true),
        ).parse({
          thing: "//src/main:quux",
          things: [
            "//src/main:bar",
            "//src/main:baz",
          ],
          irrelevant_things: [
            "a.rb",
            "b.rb",
          ],
        }),
      )
      assert_equal [
        Label["//src/main:bar"],
        Label["//src/main:baz"],
        Label["//src/main:quux"],
      ].to_set, target.dependencies
    end
  end

  class Gzip
    def self.open(io, &block)
      Zlib::GzipReader.wrap(io, &block)
    end
  end

  class GzipTest < Test
    def test_extracts_content
      contents = ""

      StringIO.open(contents) do |io|
        Zlib::GzipWriter.wrap(io) do |gz|
          gz.write("Hello!")
        end
      end

      inflated = nil

      Gzip.open(StringIO.new(contents)) do |io|
        inflated = io.read
      end

      assert_equal "Hello!", inflated
    end
  end

  class Tar
    def self.foreach(io, &block)
      # https://stackoverflow.com/questions/2078778/what-exactly-is-the-gnu-tar-longlink-trick
      long_name = []

      Gem::Package::TarReader.new(io) do |tar|
        tar.each do |entry|
          if entry.header.typeflag == "L"
            long_name.push(entry.read.chomp("\0"))
          else
            name = long_name.pop || entry.full_name
            block.call(Pathname.new(name).cleanpath.to_path, entry, entry.header.mode) if entry.file?
          end
        end
      end
    end
  end

  class TarTest < Test
    def test_extracts_files
      contents = ""

      StringIO.open(contents) do |io|
        Gem::Package::TarWriter.new(io) do |tar|
          tar.add_file_simple("file.txt", 0644, 6) do |file|
            file.write("Hello!")
          end
        end
      end

      entries = {}
      Tar.foreach(StringIO.new(contents)) { |path, io, mode| entries[path] = { content: io.read, mode: mode } }
      assert_equal ["file.txt"], entries.keys
      assert_equal "Hello!", entries["file.txt"][:content]
      assert_equal 0644, entries["file.txt"][:mode]
    end

    def test_skips_directories
      contents = ""

      StringIO.open(contents) do |io|
        Gem::Package::TarWriter.new(io) do |tar|
          tar.mkdir("other", 0755)
        end
      end

      entries = {}
      Tar.foreach(StringIO.new(contents)) { |path, io| entries[path] = io.read }
      assert_equal [], entries.keys
    end
  end

  class TarGzip
    def self.foreach(io, &block)
      Gzip.open(io) do |inflated_io|
        Tar.foreach(inflated_io, &block)
      end
    end
  end

  class PathCleaner
    def self.parse(strip_components)
      new(strip_components: strip_components)
    end

    def initialize(strip_components:)
      @strip_components = strip_components
    end

    def stripped_path(name)
      path = Pathname.new(name).cleanpath.to_path
      components = path.split("/")
      components.shift(@strip_components)
      result = components.join("/")
      result unless result.empty?
    end

    def to_s
      "PathCleaner(strip_components: #{@strip_components})"
    end
  end

  class PathCleanerTest < Test
    def test_cleans_paths
      assert_equal "path/to/file.txt", PathCleaner.new(strip_components: 0).stripped_path("./path/to/file.txt")
    end

    def test_strips_components
      assert_equal "my/file.txt", PathCleaner.new(strip_components: 2).stripped_path("./path/to/my/file.txt")
    end

    def test_skips_stripped_components
      assert_nil PathCleaner.new(strip_components: 2).stripped_path("./bar.txt")
    end
  end

  class MavenCoordinates
    def self.parse(string)
      string.match %r{^([^:]+):([^:]+):([^:@]+)(?::(\w+))?(?:@(\w+))?$} do |match|
        new(match[1], match[2], match[3], classifier: match[4], packaging: match[5] || :jar)
      end
    end

    def initialize(group, artifact, version, classifier: nil, packaging: :jar)
      @group = group
      @artifact = artifact
      @version = version
      @classifier = classifier
      @packaging = packaging
    end

    def filename
      [[@artifact, @version, @classifier].compact.join("-"), @packaging].join(".")
    end

    def label_name
      [@classifier, @packaging].compact.join("_")
    end

    def package_path
      "#{@group.gsub(".", "_")}/#{@artifact.gsub("-", "_")}"
    end

    def url(repository)
      repository + [repository.path, *@group.split("."), @artifact, @version, filename].join("/")
    end
  end

  class MavenCoordinatesTest < Test
    def test_filename
      assert_equal "x-y-z-1.2.3.jar", parse("a.b.c:x-y-z:1.2.3").filename
    end

    def test_package_path
      assert_equal "a_b_c/x_y_z", parse("a.b.c:x-y-z:1.2.3").package_path
    end

    def test_url
      assert_equal URI.parse("https://example.com/maven/a/b/c/x-y-z/1.2.3/x-y-z-1.2.3.jar"),
        parse("a.b.c:x-y-z:1.2.3").url(URI.parse("https://example.com/maven"))
    end

    def test_classifier
      assert_equal "x-y-z-1.2.3-sources.jar", parse("a.b.c:x-y-z:1.2.3:sources").filename
    end

    def test_packaging
      assert_equal "x-y-z-1.2.3.pom", parse("a.b.c:x-y-z:1.2.3@pom").filename
    end

    def test_label_name
      assert_equal "jar", parse("a.b.c:x-y-z:1.2.3").label_name
    end

    def test_label_name_with_classifier_and_packaging
      assert_equal "sources_zip", parse("a.b.c:x-y-z:1.2.3:sources@zip").label_name
    end

    private

    def parse(coordinates)
      MavenCoordinates.parse(coordinates)
    end
  end

  class Plan
    def initialize(roots, &children)
      @blocked = {}
      @blocking = {}
      @available = Queue.new
      @mutex = Mutex.new

      traverse = lambda do |node, parent = nil|
        if !@blocked.key?(node)
          @blocked[node] = 0
          @blocking[node] = []
          children[node].each { |child| traverse[child, node] }
        end

        if parent
          @blocked[parent] += 1
          @blocking[node] << parent
        end
      end

      roots.each(&traverse)

      @blocked.each { |node, count| @available << node if count.zero? }
      @blocked.delete_if { |node, count| count.zero? }
    end

    def each(&block)
      if !@available.empty?
        while node = @available.pop
          block.call(node)
          cleanup(node)
        end
      end
    end

    private

    def cleanup(node)
      @mutex.synchronize do
        @blocking[node].each do |parent|
          @blocked[parent] -= 1
          if @blocked[parent] == 0
            @blocked.delete(parent)
            @available << parent
          end
        end

        if @blocked.empty?
          @available.close
        end
      end
    end
  end

  class PlanTest < Test
    def test_each_dependency_ordering
      #   a     b
      #  / \    |
      # c   d   e
      #    / \ / \
      #   f   g   h
      #      / \
      #     i   j
      edges = {
        a: [:c, :d],
        b: [:e],
        c: [],
        d: [:f, :g],
        e: [:g, :h],
        f: [],
        g: [:i, :j],
        h: [],
        i: [],
        j: [],
      }
      record = []
      plan = Plan.new([:a, :b]) { |node| edges[node] }
      plan.each { |node| record << node }
      assert_equal [:c, :f, :i, :j, :h, :g, :d, :e, :a, :b], record
    end

    def test_each_nothing
      record = []
      plan = Plan.new([]) { |node| [] }
      plan.each { |node| record << node }
      assert_equal [], record
    end

    def test_each_no_dependencies
      record = []
      plan = Plan.new([:a, :b]) { |node| [] }
      plan.each { |node| record << node }
      assert_equal [:a, :b], record
    end

    def skip_test_each_parallel_processing
      skip "Seems like these can be flaky."
      record = Queue.new
      plan = Plan.new([:a, :b, :c, :d, :e, :f, :g, :h, :i, :j, :k]) { |node| [] }
      threads = Array.new(3) { |i| Thread.new { plan.each { |node| record << [node, i]; Thread.pass } } }
      threads.each(&:join)
      record_array = []
      record_array << record.pop until record.empty?
      assert_equal [:a, :b, :c, :d, :e, :f, :g, :h, :i, :j, :k], record_array.map(&:first)
      assert_equal [0, 1, 2], record_array.map(&:last).sort.uniq, "Every thread should be part of the processing"
    end

    def test_each_parallel_processing_with_dependency_ordering
      edges = {
        a: [:c, :d],
        b: [:e],
        c: [],
        d: [:f, :g],
        e: [:g, :h],
        f: [],
        g: [:i, :j],
        h: [],
        i: [],
        j: [],
      }
      record = Queue.new
      plan = Plan.new([:a, :b]) { |node| edges[node] }
      threads = Array.new(3) { Thread.new { plan.each { |node| record << node; Thread.pass } } }
      threads.each(&:join)
      assert_equal 10, record.length
    end

    def test_each_avoiding_deadlock
      edges = {
        a: [:c, :d],
        b: [:e],
        c: [],
        d: [:f, :g],
        e: [:g, :h],
        f: [],
        g: [:i, :j],
        h: [],
        i: [],
        j: [],
      }
      record = Queue.new
      plan = Plan.new([:a, :b]) { |node| edges[node] }
      threads = Array.new(3) { Thread.new { plan.each { |node| record << node; Thread.pass } } }
      threads.each(&:join)
    end
  end

  # https://stackoverflow.com/questions/4922867/what-is-the-junit-xml-format-specification-that-hudson-supports/9691131#9691131
  class TestCase
    class Error < Struct.new(:type, :message, :backtrace)
      def self.json_create(object)
        new(
          object.fetch("type"),
          object.fetch("message"),
          object.fetch("backtrace")
        )
      end
    end

    class Failure < Struct.new(:message, :location)
      def self.json_create(object)
        new(
          object.fetch("message"),
          object.fetch("location")
        )
      end
    end

    class Skipped < Struct.new(:message)
      def self.json_create(object)
        new(object.fetch("message"))
      end
    end

    def self.json_create(object)
      new(
        class_name: object.fetch("class_name"),
        name: object.fetch("name"),
        time: object.fetch("time"),
        skipped: object.fetch("skipped", []).map(&Skipped.method(:json_create)),
        errors: object.fetch("errors", []).map(&Error.method(:json_create)),
        failures: object.fetch("failures", []).map(&Failure.method(:json_create)),
      )
    end

    include Comparable

    attr_reader :ansi_color_code
    attr_reader :result_code
    attr_reader :result_label

    def initialize(**kwargs)
      @class_name = kwargs.fetch(:class_name)
      @name = kwargs.fetch(:name)
      @time = kwargs.fetch(:time)
      @skipped = kwargs.fetch(:skipped)
      @errors = kwargs.fetch(:errors)
      @failures = kwargs.fetch(:failures)

      location = "#{@class_name}##{@name}"

      if @skipped.any?
        @rank = 1
        @result_label = "Skipped"
        @result_code = "S"
        @ansi_color_code = "0"
        @to_s = "#{location}:\n#{@skipped.first.message}"
      elsif @failures.any?
        @rank = 2
        @result_label = "Failed"
        @result_code = "F"
        @ansi_color_code = "31"
        @to_s = <<~END.chomp
          #{location}:
          #{@failures.first.message}
              #{@failures.first.location}
        END
      elsif @errors.any?
        @rank = 3
        @result_label = "Error"
        @result_code = "E"
        @ansi_color_code = "33"
        @to_s = <<~END.chomp
          #{location}:
          #{@errors.first.type}: #{@errors.first.message}
              #{@errors.first.backtrace.join("\n    ")}
        END
      else
        @rank = 0
        @result_label = "Passed"
        @result_code = "."
        @ansi_color_code = "32"
        @to_s = location
      end
    end

    def passed?
      @skipped.empty? && !broken?
    end

    def broken?
      @errors.any? || @failures.any?
    end

    def to_s
      @to_s
    end

    def <=>(other)
      sort_key <=> other.sort_key
    end

    def sort_key
      [@rank, @class_name, @name]
    end
  end

  class LintTest < Test
    def test_all_tests_are_tests
      assert_equal [], Wake.constants.
                     select { |name| name =~ /^.+Test$/ }.
                     map { |name| Wake.const_get(name) }.
                     select { |klass| !klass.ancestors.include?(Test) }
    end
  end

  class MinitestReporter
    def initialize(console)
      @console = console
      @ok = true
    end

    def start
    end

    def record(result)
      @console.report_test_result(test_case(result))
      @ok &&= (result.passed? || result.skipped?)
    end

    def report
    end

    def passed?
      @ok
    end

    private

    def test_case(result)
      TestCase.new(
        class_name: result.class.name,
        name: result.name,
        time: result.time,
        skipped: result.failures.
          select { |f| Minitest::Skip === f }.
          collect { |f| TestCase::Skipped.new(f.message) },
        errors: result.failures.
          select { |f| Minitest::UnexpectedError === f }.
          collect { |f| TestCase::Error.new(f.error.class.name, f.error.message, Minitest.filter_backtrace(f.backtrace)) },
        failures: result.failures.
          select { |f| Minitest::Assertion === f }.
          collect { |f| TestCase::Failure.new(f.error.message, Minitest.filter_backtrace(f.error.backtrace).first) },
      )
    end
  end

  class FileGroupInfo < Struct.new(:paths)
    def only
      raise "More than one file! #{paths.inspect}" unless paths.length == 1
      paths[0]
    end
  end

  class FileInfo < Struct.new(:path)
    # TODO any behavior?
  end

  class JavaArchiverInfo < Struct.new(:jar, :libs, keyword_init: true)
    def files
      [jar, *libs]
    end

    def arguments
      # So, it seems like, when we have multiple jvms running, there's some leakage of knowledge about where ${JAVA_HOME}/lib is.
      [
        "-J-Djava.home=%{pwd}/#{java_home}",
        "-J-Djava.library.path=%{pwd}/#{java_home}/lib",
        "-J-Dsun.boot.library.path=%{pwd}/#{java_home}/lib",
      ]
    end

    private

    def java_home
      jar.chomp("/bin/jar")
    end
  end

  class JavaInfo < Struct.new(:jar, :deps, keyword_init: true)
    def transitive_runtime_dependencies
      [jar, *deps.map { |dep| dep.transitive_runtime_dependencies }]
    end
  end

  class JavaRuntimeInfo < Struct.new(:java, :libs, keyword_init: true)
    def files
      [java, *libs]
    end

    def arguments(debug: false)
      # So, it seems like, when we have multiple jvms running, there's some leakage of knowledge about where ${JAVA_HOME}/lib is.
      result = [
        "-Djava.home=%{pwd}/#{java_home}",
        "-Djava.library.path=%{pwd}/#{java_home}/lib",
        "-Dsun.boot.library.path=%{pwd}/#{java_home}/lib",
      ]

      # To debug: ./var/tmp/lib/java/jdk15_macos/bin/jdb -attach localhost:9253
      if debug
        result << "-agentlib:jdwp=transport=dt_socket,server=y,address=9253"
      end

      result
    end

    private

    def java_home
      java.chomp("/bin/java")
    end
  end

  class NodeRuntimeInfo < Struct.new(:node, keyword_init: true)
  end

  # https://kotlinlang.org/docs/reference/compiler-reference.html
  class KotlinJsCompilerInfo < Struct.new(:java_runtime, :classpath, keyword_init: true)
    def compile(srcs:, deps:, plugins:, context:)
      classpath = self.classpath.map(&:transitive_runtime_dependencies).flatten.sort.uniq

      source_paths = srcs.map { |path| context.expand_path(path) }
      dependencies = deps.map { |dep| dep.fetch(KotlinJsInfo) }
      dependency_paths = dependencies.map(&:transitive_compilation_dependencies).flatten.sort.uniq
      plugin_paths = plugins.map { |plugin| plugin.fetch(JavaInfo).jar }

      output_js = context.expand_path("lib%{name}.js")
      output_klib = context.expand_path("lib%{name}.js.klib")

      parameters = [
        "-api-version", "1.4",
        "-language-version", "1.4",
        "-no-stdlib",
        "-target", "v6",
        "-Werror",
        "-Xir-dce",
        "-Xir-produce-js",
        "-Xir-produce-klib-file",
        "-Xmulti-platform",
        "-Xopt-in=kotlin.RequiresOptIn",
        *plugin_paths.map { |path| "-Xplugin=#{path}" },
      ]

      context.run(
        inputs: [*java_runtime.files, *classpath, *plugin_paths, *source_paths, *dependency_paths],
        parameters: [*java_runtime.arguments, *parameters],
        outputs: [output_js, output_klib],
      ) do |fs|
        fs.exec!(
          java_runtime.java,
          java_runtime.arguments(debug: context.debug?),
          "-cp", classpath.join(":"),
          # TODO remove once fixed in intellij-core and taken up by kotlin-compiler
          # https://youtrack.jetbrains.com/issue/KT-43704
          # https://youtrack.jetbrains.com/issue/IDEA-24878
          "--add-opens", "java.base/java.util=ALL-UNNAMED",
          "org.jetbrains.kotlin.cli.js.K2JSCompiler",
          "-libraries", dependency_paths.join(":"),
          "-output", output_js,
          parameters,
          source_paths,
        )
      end

      [KotlinJsInfo.new(
        js: output_js,
        klib: output_klib,
        deps: dependencies,
      )]
    end
  end

  class KotlinJvmCompilerInfo < Struct.new(:java_runtime, :classpath, keyword_init: true)
    def compile(srcs:, deps:, plugins:, context:)
      classpath = self.classpath.map(&:transitive_runtime_dependencies).flatten.sort.uniq

      source_paths = srcs.map { |path| context.expand_path(path) }
      dependencies = deps.map { |dep| dep.fetch(JavaInfo) }
      dependency_paths = dependencies.map { |java_info| java_info.jar }
      plugin_paths = plugins.map { |plugin| plugin.fetch(JavaInfo).jar }
      output = context.expand_path("lib%{name}.jar")

      kotlinc_parameters = [
        "-api-version", "1.4",
        "-cp", dependency_paths.join(":"),
        "-d", output,
        "-language-version", "1.4",
        "-jvm-target", "15",
        "-no-reflect",
        "-no-stdlib",
        "-Werror",
        "-Xmulti-platform",
        "-Xopt-in=kotlin.RequiresOptIn",
        "-Xuse-ir",
        *plugin_paths.map { |path| "-Xplugin=#{path}" },
        source_paths,
      ]

      context.run(
        inputs: [*java_runtime.files, *classpath, *plugin_paths, *source_paths, *dependency_paths],
        parameters: [*java_runtime.arguments, *kotlinc_parameters],
        outputs: [output],
      ) do |fs|
        fs.exec!(
          java_runtime.java,
          java_runtime.arguments,
          "-cp", classpath.join(":"),
          # TODO remove once fixed in intellij-core and taken up by kotlin-compiler
          # https://youtrack.jetbrains.com/issue/KT-43704
          # https://youtrack.jetbrains.com/issue/IDEA-24878
          "--add-opens", "java.base/java.util=ALL-UNNAMED",
          "org.jetbrains.kotlin.cli.jvm.K2JVMCompiler",
          kotlinc_parameters,
        )
      end

      [JavaInfo.new(
        jar: output,
        deps: dependencies,
      )]
    end
  end

  class KotlinNativeCompilerInfo < Struct.new(:java_runtime, :classpath, :files, keyword_init: true)
    def compile(context:, srcs:, deps:, plugins:)
      source_paths = srcs.map { |path| context.expand_path(path) }
      dependencies = deps.map { |dep| dep.fetch(KotlinNativeInfo) }
      dependency_paths = dependencies.map(&:klib)
      plugin_paths = plugins.map { |plugin| plugin.fetch(JavaInfo).jar }
      output = context.expand_path("lib%{name}.klib")

      java_parameters = [
        "-Dkonan.home=%{pwd}/#{konan_home}",
      ]

      kotlinc_parameters = [
        "-api-version", "1.4",
        "-language-version", "1.4",
        *dependency_paths.flat_map { |path| ["-library", path] },
        "-o", output.chomp(".klib"),
        "-produce", "library",
        "-Werror",
        "-Xmulti-platform",
        "-Xopt-in=kotlin.RequiresOptIn",
        *plugin_paths.map { |path| "-Xplugin=#{path}" },
      ]

      env = {
        "KONAN_DATA_DIR" => konan_data_dir,
      }

      context.run(
        inputs: [*java_runtime.files, *classpath, *files, *plugin_paths, *source_paths, *dependency_paths],
        parameters: [*java_runtime.arguments, *java_parameters, *kotlinc_parameters, *env],
        outputs: [output],
      ) do |fs|
        fs.exec!(
          java_runtime.java,
          java_runtime.arguments,
          java_parameters,
          "-cp",
          classpath.join(":"),
          # TODO remove once fixed in intellij-core and taken up by kotlin-compiler
          # https://youtrack.jetbrains.com/issue/KT-43704
          # https://youtrack.jetbrains.com/issue/IDEA-24878
          "--add-opens", "java.base/java.util=ALL-UNNAMED",
          "org.jetbrains.kotlin.cli.utilities.MainKt",
          "konanc",
          kotlinc_parameters,
          source_paths,
          env: env,
        )
      end

      [KotlinNativeInfo.new(
        klib: output,
        deps: dependencies,
      )]
    end

    def compile_test_binary(context:, srcs:, deps:, plugins:)
      source_paths = srcs.map { |path| context.expand_path(path) }
      dependency_paths = deps.map { |dep| dep.fetch(KotlinNativeInfo).transitive_runtime_dependencies }.flatten.sort.uniq
      plugin_paths = plugins.map { |plugin| plugin.fetch(JavaInfo).jar }
      output = context.expand_path("%{name}.kexe")

      java_parameters = [
        "-Dkonan.home=%{pwd}/#{konan_home}",
      ]

      kotlinc_parameters = [
        "-api-version", "1.4",
        "-language-version", "1.4",
        *dependency_paths.flat_map { |path| ["-library", path] },
        "-o", output.chomp(".kexe"),
        "-Werror",
        "-Xmulti-platform",
        "-Xopt-in=kotlin.RequiresOptIn",
        *plugin_paths.map { |path| "-Xplugin=#{path}" },
      ]

      env = {
        "KONAN_DATA_DIR" => konan_data_dir,
      }

      context.run(
        inputs: [*java_runtime.files, *classpath, *files, *plugin_paths, *source_paths, *dependency_paths],
        parameters: [*java_runtime.arguments, *java_parameters, *kotlinc_parameters, *env],
        outputs: [output],
      ) do |fs|
        fs.exec!(
          java_runtime.java,
          java_runtime.arguments,
          java_parameters,
          "-cp",
          classpath.join(":"),
          # TODO remove once fixed in intellij-core and taken up by kotlin-compiler
          # https://youtrack.jetbrains.com/issue/KT-43704
          # https://youtrack.jetbrains.com/issue/IDEA-24878
          "--add-opens", "java.base/java.util=ALL-UNNAMED",
          "org.jetbrains.kotlin.cli.utilities.MainKt",
          "konanc",
          kotlinc_parameters,
          source_paths,
          env: env,
        )
      end

      [TestExecutableInfo.new(
        context: context,
        executable: output,
        runfiles: [],
        arguments: [],
        env: {},
      )]
    end

    private

    def konan_data_dir
      File.join(konan_home, "data")
    end

    def konan_home
      files.detect { |path| File.basename(path) == "konan.properties" }.
        chomp("/konan/konan.properties")
    end
  end

  class KotlinJsInfo < Struct.new(:js, :klib, :deps, keyword_init: true)
    def transitive_compilation_dependencies
      [klib, *deps.map(&:transitive_compilation_dependencies)]
    end
  end

  class KotlinNativeInfo < Struct.new(:klib, :deps, keyword_init: true)
    def transitive_runtime_dependencies
      [klib, *deps.map(&:transitive_runtime_dependencies)]
    end
  end

  class TestExecutableInfo < Struct.new(:context, :executable, :runfiles, :arguments, :env, keyword_init: true)
    def run(&block)
      out = context.expand_path("%{name}-out.txt")

      process_test_output = lambda do |io|
        until io.eof?
          block.call(TestCase.json_create(JSON.parse(io.readline.chomp)))
        end
      end

      action_did_run = false

      context.run(
        inputs: [executable, *runfiles],
        parameters: [*arguments, *env.flatten],
        outputs: [out],
      ) do |fs|
        action_did_run = true
        rd, wr = IO.pipe
        reader = Thread.new(rd, &process_test_output)
        fs.open(out, "wb") do |io|
          fs.exec!(executable, *arguments, out: CompositeIO.new(io, wr), env: env)
        end
        wr.close
        reader.join
      end

      if !action_did_run
        # TODO var/tmp is duplication with Actions
        File.open(File.join("var/tmp", out), "rb", &process_test_output)
      end
    end
  end

  if Kernel.const_defined?(:Minitest)
    Minitest.extensions << :wake
    def Minitest.plugin_wake_init(options)
      $stdout = console = Console.new(options[:io])
      reporter.reporters = [MinitestReporter.new(console)]
      at_exit { console.join }
    end
  elsif __FILE__ == $0
    STDOUT.sync = true
    exit Wake.run(*ARGV)
  end
end
